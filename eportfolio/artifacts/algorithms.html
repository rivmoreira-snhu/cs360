<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Enhancement 2 • Algorithms & Data Structures • CS499 ePortfolio</title>
  <link rel="icon" href="../assets/favicon.png">
  <link rel="stylesheet" href="../assets/css/styles.css">
  <script defer src="../assets/js/main.js"></script>
</head>
<body>
  
<nav class="nav" role="navigation" aria-label="Main">
  <a href="#main" class="skip-link">Skip to content</a>
  <div class="container">
      <a class="brand" href="/cs360/eportfolio">Angel M. Rivera Moreira  CS499</a>
    <div class="links" role="menubar">
        <a href='/cs360/eportfolio'>Self-Assessment</a>
        <a href='/cs360/eportfolio/code-review.html'>Code Review</a>
      <a href='software-engineering.html' >Software Eng.</a>
      <a href='algorithms.html'  style='border-color: var(--accent)'>Algorithms & DS</a>
      <a href='databases.html' >Databases</a>
    </div>
  </div>
</nav>

  <main id="main" class="container" role="main">
    <h1>Enhancement 2 • Algorithms & Data Structures</h1>
    <section class="card">
      <h2>Artifact</h2>
      <p><strong>Minimal Calendar App (Android / SQLite):</strong> An event‑tracking app with login, CRUD, and daily view.</p>
      <ul>
        <li>Planned event grouping with <code>Map&lt;String, List&lt;Event&gt;&gt;</code> for efficient date‑based rendering.</li><li>Hardened login path with hashing and parameterized queries; defensive input validation.</li><li>Clarified logic paths to support future RecyclerView integration.</li>
      </ul>
      <p class="notice">Add before/after screenshots or code snippets that illustrate the enhancements.</p>
    </section>
    <section class="card">
      <h2>Links & Evidence</h2>
      <ul>
        <li><a href='../files/Milestone Three.pdf'>Narrative (Algorithms & DS)</a></li>
        <li><a href='../files/MilestoneThreecode.zip'>Original & Enhanced Code (zip)</a></li>
        <li><a href="https://github.com/rivmoreira-snhu/cs360" target="_blank" rel="noopener">GitHub repository (link)</a></li>
      </ul>
    </section>
    <section class="card">
  <h2>Code Snippets</h2>

  <h3>Before > After: deterministic, ID-based behavior</h3>
  <p><em>Problem:</em> Earlier UI actions were loosely tied to view state; deletions/updates could become ambiguous. <br>
     <em>Fix:</em> Pass a stable <code>eventId</code> through the UI and bind actions to that ID only.</p>

  <pre><code class="language-java">// CalendarActivityEnhanced.java
// Each item is inflated with its stable primary key so actions are predictable.
private void inflateEventItem(int eventId, String title, String time, String location) {
    View item = getLayoutInflater().inflate(R.layout.event_item, eventList, false);

    TextView titleView = item.findViewById(R.id.eventTitle);
    TextView timeView  = item.findViewById(R.id.eventTime);
    TextView locView   = item.findViewById(R.id.eventLocation);
    Button   delBtn    = item.findViewById(R.id.deleteButton);

    titleView.setText(title);
    timeView.setText(time);
    locView.setText(location);

    delBtn.setOnClickListener(v -> {
        boolean deleted = dbHelper.deleteEvent(eventId);
        Toast.makeText(this, deleted ? "Event deleted" : "Error deleting event", Toast.LENGTH_SHORT).show();
        if (deleted) loadEventsFromDatabase();
    });

    eventList.addView(item);
}</code></pre>

  <details>
    <summary><strong>Before (for contrast)</strong></summary>
    <pre><code class="language-java">// CalendarActivity.java (earlier)
// Note: UI actions were not bound to a stable eventId; behavior depended on view state.
private void inflateEventItem(String title, String time, String location) {
    View item = getLayoutInflater().inflate(R.layout.event_item, eventList, false);
    // ... sets text fields only, no eventId awareness ...
    eventList.addView(item);
}</code></pre>
  </details>

  <h3>Single-pass load with explicit columns (linear time)</h3>
  <p><em>What changed:</em> Pull only the needed columns, create items in O(n), and render an empty state if no rows exist.</p>
  <pre><code class="language-java">// CalendarActivityEnhanced.java
private void loadEventsFromDatabase() {
    eventList.removeAllViews();
    Cursor cursor = dbHelper.getEventsCursorForDate(currentDateString); // returns id, title, time, location
    if (cursor != null && cursor.moveToFirst()) {
        do {
            int    id   = cursor.getInt(cursor.getColumnIndexOrThrow(DbConfig.COLUMN_EVENT_ID));
            String t    = cursor.getString(cursor.getColumnIndexOrThrow(DbConfig.COLUMN_EVENT_TITLE));
            String time = cursor.getString(cursor.getColumnIndexOrThrow(DbConfig.COLUMN_EVENT_TIME));
            String loc  = cursor.getString(cursor.getColumnIndexOrThrow(DbConfig.COLUMN_EVENT_LOCATION));
            inflateEventItem(id, t, time, loc);
        } while (cursor.moveToNext());
        cursor.close();
    } else {
        TextView empty = new TextView(this);
        empty.setText("No events available. Tap '+' to add one.");
        eventList.addView(empty);
    }
}</code></pre>

  <h3>DB operations bound to primary key</h3>
  <p><em>Why it matters:</em> Algorithms are only as reliable as their identifiers. DB-layer guarantees the ID contract, UI consumes it.</p>
  <pre><code class="language-java">// DatabaseHelperEnhanced.java
      public boolean deleteEvent(int id) {
          SQLiteDatabase db = this.getWritableDatabase();
          int rows = db.delete(DbConfig.TABLE_EVENTS, DbConfig.COLUMN_EVENT_ID + "=?",
                              new String[]{ String.valueOf(id) });
          db.close();
          return rows > 0;
      }

      // Narrow cursor for UI loading: only the columns needed for rendering.
      public Cursor getEventsCursorForDate(String date) {
          SQLiteDatabase db = this.getReadableDatabase();
          String[] cols = {
              DbConfig.COLUMN_EVENT_ID,
              DbConfig.COLUMN_EVENT_TITLE,
              DbConfig.COLUMN_EVENT_TIME,
              DbConfig.COLUMN_EVENT_LOCATION
          };
          return db.query(DbConfig.TABLE_EVENTS, cols,
                  DbConfig.COLUMN_EVENT_DATE + "=?",
                  new String[]{ date }, null, null,
                  DbConfig.COLUMN_EVENT_TIME + " ASC");
      }</code></pre>

        <h3>Planned DS upgrade: date-keyed grouping (future RecyclerView)</h3>
        <p>Planned structure for grouped rendering and section headers; one scan, O(n) insert.</p>
        <pre><code class="language-java">// Pseudocode: group events by date for scalable rendering (RecyclerView ready)
      Map&lt;String, List&lt;Event&gt;&gt; grouped = new HashMap<>();
      for (Event e : events) {
          grouped.computeIfAbsent(e.date(), k -&gt; new ArrayList&lt;&gt;()).add(e);
      }
      // UI renders per-date sections (stable order), enabling efficient updates and virtualization.</code></pre>

        <p><em>Outcome tie-in:</em> This enhancement demonstrates algorithm design (stable-ID workflows, linear scans),
          data structure selection (future date>events Map), and explicit trade-offs (simple list now, grouped sections when RecyclerView lands). :contentReference[oaicite:1]{index=1}</p>
      </section>
    <section class="card">
      <h2>Reflection & Outcomes</h2>
      <ul>
        <li>What changed and why it matters (trade‑offs, constraints, risks)</li>
        <li>Testing & validation performed; results</li>
        <li>Course outcomes addressed</li>
      </ul>
    </section>
    <div class="footer">
      <p>© 2025 Angel M. Rivera Moreira</p>
    </div>
  </main>
</body>
</html>
